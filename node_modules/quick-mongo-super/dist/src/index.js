"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const mongodb_1 = require("mongodb");
const node_fetch_1 = __importDefault(require("node-fetch"));
const Emitter_1 = __importDefault(require("./classes/Emitter"));
const DatabaseError_1 = __importDefault(require("./classes/DatabaseError"));
const Utils_1 = __importDefault(require("./classes/Utils"));
const errors_1 = __importDefault(require("./errors"));
const package_json_1 = __importDefault(require("../package.json"));
/**
 * QuickMongo class.
 * @param {MongoConnectionOptions} options MongoDB connection options.
 */
class Mongo extends Emitter_1.default {
    ready = false;
    options;
    mongoClientOptions;
    mongo;
    database;
    collection;
    utils = new Utils_1.default();
    constructor(options) {
        super();
        if (!options.connectionURI) {
            throw new DatabaseError_1.default(errors_1.default.connection.uri.notSpecified);
        }
        if (typeof options.connectionURI !== 'string') {
            throw new DatabaseError_1.default(errors_1.default.connection.uri.invalid);
        }
        if (options.collectionName && typeof options.collectionName !== 'string') {
            throw new DatabaseError_1.default(errors_1.default.invalidType('options.collectionName', 'string', options.collectionName));
        }
        if (options.dbName && typeof options.dbName !== 'string') {
            throw new DatabaseError_1.default(errors_1.default.invalidType('options.dbName', 'string', options.dbName));
        }
        if (options.mongoClientOptions && typeof options.mongoClientOptions !== 'object') {
            throw new DatabaseError_1.default(errors_1.default.invalidType('options.mongoClientOptions', 'object', options.mongoClientOptions));
        }
        this.options = options;
        this.mongoClientOptions = options?.mongoClientOptions;
    }
    /**
     * Connects to the database.
     * @returns {Promise<Collection<Document>>} If connected - MongoDB collection will be returned.
     */
    async connect() {
        if (this.ready) {
            throw new DatabaseError_1.default(errors_1.default.connection.alreadyConnected);
        }
        const mongoClient = new mongodb_1.MongoClient(this.options.connectionURI, this.mongoClientOptions);
        this.emit('connecting');
        const mongo = await mongoClient.connect().catch((err) => {
            if (err.message.toLowerCase().includes('bad auth')) {
                throw new DatabaseError_1.default(errors_1.default.connection.badAuth);
            }
            throw new DatabaseError_1.default(errors_1.default.connection.failedToConnect + err);
        });
        if (!mongo) {
            throw new DatabaseError_1.default(errors_1.default.connection.connectionFailure);
        }
        this.mongo = mongo;
        this.database = mongo.db(this.options.dbName || 'db');
        this.collection = this.database.collection(this.options.collectionName || 'database');
        this.emit('ready', this.collection);
        this.ready = true;
        return this.collection;
    }
    /**
    * Closes the connection.
    * @returns {Promise<boolean>} If closed - true will be returned.
    */
    async disconnect() {
        if (!this.ready) {
            throw new DatabaseError_1.default(errors_1.default.connection.alreadyDestroyed);
        }
        this.ready = false;
        await this.mongo.close();
        this.emit('destroy', this.mongo);
        return true;
    }
    /**
    * Checks for the module updates.
    * @returns {Promise<VersionData>} Is the module updated, latest version and installed version.
    */
    async checkUpdates() {
        const version = package_json_1.default.version;
        const packageData = await (0, node_fetch_1.default)('https://registry.npmjs.com/quick-mongo-super').then(res => res.json());
        if (version == packageData['dist-tags'].latest)
            return {
                updated: true,
                installedVersion: version,
                packageVersion: packageData['dist-tags'].latest
            };
        return {
            updated: false,
            installedVersion: version,
            packageVersion: packageData['dist-tags'].latest
        };
    }
    /**
     * Sends a read, write and delete request to the database
     * and returns the request latencies.
     * @returns {Promise<MongoLatencyData>} Database latency object.
     */
    async ping() {
        let readLatency = -1;
        let writeLatency = -1;
        let deleteLatency = -1;
        if (!this.ready) {
            throw new DatabaseError_1.default(errors_1.default.connection.noConnection);
        }
        // write latency checking
        const writeStartDate = Date.now();
        await this.set('___PING___', 1);
        writeLatency = Date.now() - writeStartDate;
        // read latency checking
        const readStartDate = Date.now();
        await this.fetch('___PING___');
        readLatency = Date.now() - readStartDate;
        // delete latency checking
        const deleteStartDate = Date.now();
        await this.delete('___PING___');
        deleteLatency = Date.now() - deleteStartDate;
        return {
            readLatency,
            writeLatency,
            deleteLatency
        };
    }
    /**
     * Checks if the element is existing in database.
     * @param {string} key The key in database
     * @returns {Promise<boolean>} Is the element is existing in database.
     */
    async has(key) {
        const data = await this.fetch(key);
        return !!data;
    }
    /**
     * Checks if the element is existing in database.
     *
     * This method is an alias for `QuickMongo.has()` method.
     * @param {string} key The key in database
     * @returns {Promise<boolean>} Is the element is existing in database.
     */
    async includes(key) {
        return this.has(key);
    }
    /**
     * Gets the random element of array in database.
     *
     * [!!!] The target must be an array.
     * @param {string} key The key in database.
     * @returns {T} The random element in array.
     */
    async random(key) {
        const array = await this.fetch(key);
        if (!array) {
            throw new DatabaseError_1.default(errors_1.default.requiredParameterMissing('key'));
        }
        if (!Array.isArray(array)) {
            throw new DatabaseError_1.default(errors_1.default.target.notArray + typeof array);
        }
        return array[Math.floor(Math.random() * array.length)];
    }
    /**
    * Gets a list of keys in database.
    * @param {string} key The key in database.
    * @returns {Promise<string[]>} An array with all keys in database.
    */
    async keysList(key) {
        const data = await this.find(key);
        if (key == '') {
            const rawData = await this.raw();
            return rawData.map(obj => obj.__KEY);
        }
        return Object.keys(data).filter(key => data[key] !== undefined && data[key] !== null);
    }
    /**
     * Fetches the data from the database.
     * @param {string} key The key in database.
     * @returns {Promise<T>} Value from the database.
     */
    async fetch(key) {
        if (!key) {
            throw new DatabaseError_1.default(errors_1.default.requiredParameterMissing('key'));
        }
        if (typeof key !== 'string') {
            throw new DatabaseError_1.default(errors_1.default.invalidTypes.key + typeof key);
        }
        let parsed = await this.all();
        const keys = key.split('.');
        let database = parsed;
        for (let i = 0; i < keys.length; i++) {
            if (keys.length - 1 == i) {
                parsed = database?.[keys[i]] || null;
            }
            database = database?.[keys[i]];
        }
        return parsed || null;
    }
    /**
     * Sets data in a property in database.
     * @param {string} key The key in database.
     * @param {T} value Any data to set in property.
     * @returns {Promise<DatabaseProperties>} If set successfully: true; else: false
     */
    async set(key, value) {
        const { isObject } = this.utils;
        const fetched = await this.all();
        if (!key) {
            throw new DatabaseError_1.default(errors_1.default.requiredParameterMissing('key'));
        }
        if (typeof key !== 'string') {
            throw new DatabaseError_1.default(errors_1.default.invalidTypes.key + typeof key);
        }
        if (value == undefined) {
            throw new DatabaseError_1.default(errors_1.default.requiredParameterMissing('value'));
        }
        if (typeof value == 'function') {
            throw new DatabaseError_1.default(errors_1.default.invalidTypes.functionIsValue);
        }
        const keys = key.split('.');
        let database = fetched;
        for (let i = 0; i < keys.length; i++) {
            if (keys.length - 1 == i) {
                database[keys[i]] = value;
            }
            else if (!isObject(database[keys[i]])) {
                database[keys[i]] = {};
            }
            database = database?.[keys[i]];
        }
        const data = await this.collection.findOne({
            __KEY: keys[0]
        });
        if (!data) {
            this.collection.insertOne({
                __KEY: keys[0],
                __VALUE: fetched[keys[0]]
            });
        }
        else {
            await this.collection.updateOne({
                __KEY: keys[0]
            }, {
                $set: {
                    __VALUE: fetched[keys[0]]
                }
            });
        }
        return fetched;
    }
    /**
    * Removes the property from the existing object in database.
    * @param {string} key The key in database.
    * @returns {Promise<DatabaseProperties>} If cleared: true; else: false.
    */
    async remove(key) {
        const { isObject } = this.utils;
        const fetched = await this.all();
        if (!key) {
            throw new DatabaseError_1.default(errors_1.default.requiredParameterMissing('key'));
        }
        if (typeof key !== 'string') {
            throw new DatabaseError_1.default(errors_1.default.invalidTypes.key + typeof key);
        }
        const data = this.fetch(key);
        if (data == null || data == undefined) {
            throw new DatabaseError_1.default(errors_1.default.target.empty);
        }
        const keys = key.split('.');
        let database = fetched;
        for (let i = 0; i < keys.length; i++) {
            if (keys.length - 1 == i) {
                delete database?.[keys[i]];
            }
            else if (!isObject(database?.[keys[i]])) {
                database[keys[i]] = {};
            }
            database = database?.[keys[i]];
        }
        if (keys.length == 1) {
            await this.collection.deleteOne({
                __KEY: key
            });
        }
        else {
            await this.collection.updateOne({
                __KEY: keys[0]
            }, {
                $set: {
                    __VALUE: fetched[keys[0]]
                }
            });
        }
        return fetched;
    }
    /**
     * Removes the property from the existing object in database.
     *
     * This method is an alias for `QuickMongo.remove()` method.
     * @param {string} key The key in database.
     * @returns {Promise<DatabaseProperties>} If cleared: true; else: false.
     */
    async delete(key) {
        return this.remove(key);
    }
    /**
     * Clears the whole database.
     * @returns {Promise<boolean>} If cleared: true; else: false.
     */
    async deleteAll() {
        const keys = await this.keysList('');
        for (const key of keys) {
            await this.remove(key);
        }
        return true;
    }
    /**
     * Clears the whole database.
     *
     * This method is an alias for `QuickMongo.deleteAll()` method.
     * @returns {Promise<boolean>} If cleared: true; else: false.
     */
    clear() {
        return this.deleteAll();
    }
    /**
     * Adds a number to a property data in database.
     *
     * [!!!] The target must be a number.
     * @param {string} key The key in database.
     * @param {number} value Any number to add.
     * @returns {Promise<DatabaseProperties>} If added successfully: true; else: false
     */
    async add(key, value) {
        const data = (await this.fetch(key)) || 0;
        if (typeof value !== 'number') {
            throw new DatabaseError_1.default(errors_1.default.invalidTypes.valueNumber + typeof value);
        }
        if (typeof data !== 'number') {
            throw new DatabaseError_1.default(errors_1.default.target.notNumber + typeof data);
        }
        const result = await this.set(key, data + value);
        return result;
    }
    /**
     * Subtracts a number from a property data in database.
     *
     * [!!!] The target must be a number.
     * @param {string} key The key in database.
     * @param {number} value Any number to subtract.
     * @returns {Promise<DatabaseProperties>} If set successfully: true; else: false
     */
    async subtract(key, value) {
        const data = (await this.fetch(key)) || 0;
        if (typeof value !== 'number') {
            throw new DatabaseError_1.default(errors_1.default.invalidTypes.valueNumber + typeof value);
        }
        if (typeof data !== 'number') {
            throw new DatabaseError_1.default(errors_1.default.target.notNumber + typeof data);
        }
        const result = await this.set(key, data - value);
        return result;
    }
    /**
     * Fetches the data from the database.
     *
     * This method is an alias for the `QuickMongo.fetch()` method.
     * @param {string} key The key in database.
     * @returns {Promise<T>} Value from the database.
     */
    async find(key) {
        return this.fetch(key);
    }
    /**
     * Fetches the data from the database.
     *
     * This method is an alias for the `QuickMongo.fetch()` method.
     * @param {string} key The key in database.
     * @returns {Promise<T>} Value from the database.
     */
    async get(key) {
        return this.fetch(key);
    }
    /**
     * Pushes a value to a specified array from the database.
     *
     * [!!!] The target must be an array.
     * @param {string} key The key in database.
     * @param {T} value The key in database.
     * @returns {Promise<DatabaseProperties>} If cleared: true; else: false.
     */
    async push(key, value) {
        const array = (await this.fetch(key)) || [];
        if (array && !Array.isArray(array)) {
            throw new DatabaseError_1.default(errors_1.default.target.notArray + typeof array);
        }
        array.push(value);
        return this.set(key, array);
    }
    /**
     * Removes an element from a specified array in the database.
     *
     * [!!!] The target must be an array.
     * @param {string} key The key in database.
     * @param {number} index The index in the array.
     * @returns {Promise<DatabaseProperties>} If cleared: true; else: false.
     */
    async pop(key, index) {
        const array = await this.fetch(key);
        if (!array) {
            throw new DatabaseError_1.default(errors_1.default.target.empty);
        }
        if (!Array.isArray(array)) {
            throw new DatabaseError_1.default(errors_1.default.target.notArray + typeof array);
        }
        array.splice(index, 1);
        return this.set(key, array);
    }
    /**
     * Removes an element from a specified array in the database.
     *
     * [!!!] The target must be an array.
     *
     * This method is an alias for the `QuickMongo.pop()` method.
     * @param {string} key The key in database.
     * @param {number} index The index in the array.
     * @returns {Promise<DatabaseProperties>} If cleared: true; else: false.
     */
    async removeElement(key, index) {
        return this.pop(key, index);
    }
    /**
    * Changes the specified element's value in a specified array in the database.
    *
    * [!!!] The target must be an array.
    * @param {string} key The key in database.
    * @param {number} index The index in the array.
    * @param {T} newValue The new value to set.
    * @returns {Promise<DatabaseProperties>} If cleared: true; else: false.
    */
    async pull(key, index, newValue) {
        const array = await this.fetch(key);
        if (!array) {
            throw new DatabaseError_1.default(errors_1.default.target.empty);
        }
        if (!Array.isArray(array)) {
            throw new DatabaseError_1.default(errors_1.default.target.notArray + typeof array);
        }
        array.splice(index, 1, newValue);
        return this.set(key, array);
    }
    /**
    * Changes the specified element's value in a specified array in the database.
    *
    * [!!!] The target must be an array.
    *
    * This method is an alias for the `QuickMongo.pull()` method.
    * @param {string} key The key in database.
    * @param {number} index The index in the array.
    * @param {T} newValue The new value to set.
    * @returns {Promise<DatabaseProperties>} If cleared: true; else: false.
    */
    changeElement(key, index, newValue) {
        return this.pull(key, index, newValue);
    }
    /**
    * Fetches the entire database.
    * @returns {Promise<DatabaseProperties>} Database contents
    */
    async all() {
        if (!this.ready) {
            throw new DatabaseError_1.default(errors_1.default.connection.noConnection);
        }
        const obj = {};
        const elements = await this.raw() || [];
        for (const element of elements) {
            obj[element.__KEY] = element.__VALUE;
        }
        return obj;
    }
    /**
    * Fetches the raw content of database.
    * @returns {Promise<DatabaseObject[]>} Database contents
    */
    async raw() {
        if (!this.ready) {
            throw new DatabaseError_1.default(errors_1.default.connection.noConnection);
        }
        const rawData = this.collection.find();
        const rawArray = await rawData.toArray();
        rawArray.map((element) => delete element._id);
        return rawArray;
    }
}
module.exports = Mongo;
